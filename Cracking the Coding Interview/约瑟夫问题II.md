<a name="9qyW1"></a>
### 约瑟夫问题II
**题目描述：（面试金典）**<br />约瑟夫问题是一个著名的趣题。这里我们稍稍修改一下规则。有n个人站成一列。并从头到尾给他们编号，第一个人编号为1。然后从头开始报数，第一轮依次报1，2，1，2...然后报到2的人出局。接着第二轮再从上一轮最后一个报数的人开始依次报1，2，3，1，2，3...报到2，3的人出局。以此类推直到剩下以后一个人。现在需要求的即是这个人的编号。<br />给定一个int n，代表游戏的人数。请返回最后一个人的编号<br />**测试样例：**<br />5 <br />**返回：**<br />5<br />**思路：**<br />解题思路,模仿约瑟夫环问题<br />假设n=30, 每次跳跃距离为m, 初始为m=2<br />第一次筛选后剩下为 [29, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27], m=3  <br />第二次筛选后剩下为 [23, 29, 5, 11, 17], m=4<br />第三次筛选后剩下为 [17, 23] m=5<br />此时结果已出, 最后剩下肯定是17, 其实在第二次筛选后结果已出, 因为此时n/4+1<m+1, 表示下次筛选时剩下结果小于m, 为下次筛选后的第一个, 也就是本次筛选后的最后一个.<br />为什么选择第二次的筛选结果呢?  因为此时还保留着位置信息x<br />计算出第二次筛选后x的位置为5, 则第一次筛选的位置x=(5-2)*m+1=10, 正好是17所在的位置数<br />同理, 原位置x=(10-2)*m+1=17, 所以答案为17

```
import java.util.*;

public class Joseph {
    public int getResult(int n) {
        return ysf(n, 2);
    }
    public int ysf(int n, int m) {
        int tmp = n%m==0 ? n/m : n/m+1;
        if(tmp <= m+1) {
            return (tmp-1)*m+1; //终止条件
        }
        int path = ysf(tmp, m+1); //m+1次时最后一人编号的位置
        return (path-2)*m + 1;
    }
}
```